<?php
/**
 * COmanage Registry CO Rest DCC Provisioner Target Model
 *
 * Portions licensed to the University Corporation for Advanced Internet
 * Development, Inc. ("UCAID") under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * UCAID licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * @link          http://www.internet2.edu/comanage COmanage Project
 * @package       registry-plugin
 * @since         COmanage Registry v0.9.1
 * @license       Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */

//App::uses('CakeSession', 'Model/Datasource');

App::uses("CoProvisionerPluginTarget", "Model");

// This file is generated by Composer
require_once APP . "AvailablePlugin" . DS . "RestDccProvisioner" . DS . "Vendor" . DS . "autoload.php";

class CoRestDccProvisionerTarget extends CoProvisionerPluginTarget {
  // Define class name for cake
  public $name = "CoRestDccProvisionerTarget";
  
  // Add behaviors
  public $actsAs = array('Containable');
  
  // Association rules from this model to other models
  public $belongsTo = array("CoProvisioningTarget");
  
  // Default display field for cake generated views
  public $displayField = "restdcc_url";
  
  // Validation rules for table elements
  public $validate = array(
    'co_provisioning_target_id' => array(
      'rule' => 'numeric',
      'required' => true,
      'message' => 'A CO Provisioning Target ID must be provided'
    ),
    'restdcc_url' => array(
      'rule' => 'notBlank'
    ),
    'client_id' => array(
      'rule' => 'notBlank'
    ),
    'client_secret' => array(
      'rule' => 'notBlank'
    ),
    'access_token' => array(
      'rule' => array('maxlength', 512)
    ),
    'refresh_token' => array(
      'rule' => array('maxlength', 512)
    ),
    'callback_url' => array(
      'rule' => array('maxlength', 512)
    )
  );
  
  /**
   * Establish a connection to the DCC RESTful API.
   *
   * @since  COmanage Registry v3.2.2
   * @param  String $restdcc_url Base URL of the DCC Server
   * @param  String $client_id OAuth2 Client ID
   * @param  String $client_id OAuth2 Client Secret
   * @param  String $callback_url OAuth2 Callback URL
   * @param  String $refresh_token DCC OAuth2 refresh token
   * @return Object Guzzle HTTP Client with Authorization header
   * @throws Exception
   */
  
  protected function dccConnect($target_data) {
    $restdcc_url = $target_data['restdcc_url'];
    $provider = new \League\OAuth2\Client\Provider\GenericProvider([
        'clientId'                => $target_data['client_id'],
        'clientSecret'            => $target_data['client_secret'],
        'redirectUri'             => $target_data['callback_url'],
        'urlAuthorize'            => $restdcc_url . '/oauth/oauth2/auth',
        'urlAccessToken'          => $restdcc_url . '/oauth/oauth2/token',
        'urlResourceOwnerDetails' => $restdcc_url . '/oauth/userinfo'
    ]);

    // refresh the access token
    $newAccessToken = $provider->getAccessToken('refresh_token', [
        'refresh_token' => $target_data['refresh_token']
    ]);

    $access_token = $newAccessToken->getToken();
    $refresh_token = $newAccessToken->getRefreshToken();

    if(!empty($access_token) && !empty($refresh_token)) {
      // save the updated tokens
      $target = new CoRestDccProvisionerTarget();
      $target->id = $target_data['id'];
      if($target->saveField('access_token', $access_token) &&
        $target->saveField('refresh_token', $refresh_token)) {

          $base_uri = $restdcc_url . '/rest-dcc/';
          $client = new GuzzleHttp\Client(['base_uri' => $base_uri,
                                           'timeout' => 5.0,
					   'exceptions' => false,
					   'headers' => ['Authorization' => 'Bearer ' . $access_token,
					                 'Accept' => 'application/json'
				          ]]);
          return $client;

        } else {
          $this->Flash->set(_txt('er.db.save'), array('key' => 'error'));
        }
      } else {
        $this->Flash->set(_txt('er.restdccprovisioner.access_token'), array('key' => 'error'));
    }

    return null;
  }
  
  /**
   * Provision for the specified CO Person.
   *
   * @since  COmanage Registry v3.2.3
   * @param  Array CO Provisioning Target data
   * @param  ProvisioningActionEnum Registry transaction type triggering provisioning
   * @param  Array Provisioning data, populated with ['CoPerson'] or ['CoGroup']
   * @return Boolean True on success
   * @throws RuntimeException
   */

  public function provision($coProvisioningTargetData, $op, $provisioningData) {
  
    // What actions should we run?
    $syncGroupsForPerson = false;
    $syncMembersForGroup = false;
    
    switch($op) {
      case ProvisioningActionEnum::CoPersonAdded:
      case ProvisioningActionEnum::CoPersonPetitionProvisioned:
      case ProvisioningActionEnum::CoPersonPipelineProvisioned:
      case ProvisioningActionEnum::CoPersonReprovisionRequested:
      case ProvisioningActionEnum::CoPersonUnexpired:
      case ProvisioningActionEnum::CoPersonUpdated:
        $activatePerson = 1;
        $syncGroupsForPerson = true;
        break;
      case ProvisioningActionEnum::CoPersonDeleted:
      case ProvisioningActionEnum::CoPersonExpired:
        // We never delete a DCC author, just deactivate them
        $activatePerson = 0;
        $syncGroupsForPerson = true;
        break;
      case ProvisioningActionEnum::CoPersonEnteredGracePeriod:
        // We don't do anything on grace period
        break;
      case ProvisioningActionEnum::CoGroupAdded:
      case ProvisioningActionEnum::CoGroupUpdated:
      case ProvisioningActionEnum::CoGroupReprovisionRequested:
        // We'll sync the memberships on these actions, even though for added and
        // updated it usually isn't necessary.
        $syncMembersForGroup = true;
        break;
      case ProvisioningActionEnum::CoGroupDeleted:
        // There shouldn't really be anything to do here
        // since the memberships should already have been deleted.
        break;
      default:
        throw new RuntimeException("Not Implemented");
        break;
    }

    if($syncGroupsForPerson || $syncMembersForGroup){
      $client = $this->dccConnect($coProvisioningTargetData['CoRestDccProvisionerTarget']);

      // Make a hash table of the groups in the DocDB database
      $response = $client->get('SecurityGroup');
      if($response->getStatusCode() != 200) {
        throw new RuntimeException(_txt('er.restdccprovisioner.securitygroup.query.failed'));
      }
      $securityGroup = array();
      $security_group_data = json_decode($response->getBody()->getContents(), true);
      foreach($security_group_data as $s) {
        $securityGroup[ $s['Name'] ] = $s['GroupID'];
      }
    }
    
    // Execute the actions identified, if configured
    if($syncGroupsForPerson) {
      $ret = $this->syncGroupsForCoPerson($client,
                                          $securityGroup,
                                          $provisioningData,
                                          $activatePerson);
    }
    
    if($syncMembersForGroup) {
      $ret = $this->syncMembersForCoGroup($client,
                                          $securityGroup,
                                          $provisioningData);
    }
  
    return true;
  }
  
  /**
   * Synchronize DCC access controlls for a CO Group.
   *
   * @since  COmanage Registry v3.2.3
   * @param  String  $restdcc_url Base URL of the DCC Server
   * @param  String  $client_id OAuth2 Client ID
   * @param  String  $client_id OAuth2 Client Secret
   * @param  String  $callback_url OAuth2 Callback URL
   * @param  String  $refresh_token DCC OAuth2 refresh token
   * @param  Array Provisioning data, populated with ['CoPerson'] or ['CoGroup']
   * @return Boolean true if groups are successfully synced
   * @throws Exception
   */
  
  protected function syncMembersForCoGroup($client, $security_group, $provisioningData) {

    $co_group_name = $provisioningData['CoGroup']['name'];
    if(!array_key_exists($co_group_name, $security_group)){
      // Ignore groups not in DocDB
      return true;
    }

    // Make a hash table of the all the users in the DocDB group
    $response = $client->get('UsersGroup?GroupID=' . $security_group[$co_group_name]);
    if($response->getStatusCode() != 200) {
      throw new RuntimeException(_txt('er.restdccprovisioner.usersgroup.query.failed'));
    }
    $users_group = array();
    $users_group_data = json_decode($response->getBody()->getContents(), true);
    foreach($users_group_data as $s) {
      $users_group[ $s['EmailUserID'] ] = $s['UsersGroupID'];
    }

    $args = array();
    $args['conditions']['CoGroupMember.co_group_id'] = $provisioningData['CoGroup']['id'];
    $args['conditions']['CoGroupMember.member'] = true;
    // Only pull currently valid group memberships
    $args['conditions']['AND'][] = array(
      'OR' => array(
        'CoGroupMember.valid_from IS NULL',
        'CoGroupMember.valid_from < ' => date('Y-m-d H:i:s', time())
      )
    );
    $args['conditions']['AND'][] = array(
      'OR' => array(
        'CoGroupMember.valid_through IS NULL',
        'CoGroupMember.valid_through > ' => date('Y-m-d H:i:s', time())
      )
    );
    $args['contain']['CoPerson'] = array(// We only need Identifiers for this provisioning target.
                                         // While Containable allows us to filter, Changelog doesn't
                                         // currently support that. So we pull all Identifiers and
                                         // filter later with Hash.
                                         'Identifier');

    $groupMembers = $this->CoProvisioningTarget
                         ->Co
                         ->CoGroup
                         ->CoGroupMember
                         ->find('all', $args);

    $co_users_in_group = array();

    foreach($groupMembers as $gm) {
      if(isset($gm['CoGroupMember']['member']) && $gm['CoGroupMember']['member']) {
        if(!empty($gm['CoPerson']['Identifier'])) {
          foreach($gm['CoPerson']['Identifier'] as $i) {
            if($i['type'] == 'DccDocDbID') {
              // Match found
              $dccid = $i['identifier'];
              break;
            }
          }
        }
     }

     $usersgroup_data = array(
        'EmailUserID' => $dccid,
        'GroupID' => $security_group[$co_group_name]
      );

      $co_users_in_group[$dccid] = true;
      $coPersonId = $gm['CoPerson']['id'];

      // If the user is not already in the DocDB group, add them
      if(!array_key_exists( $dccid, $users_group )) {
        $response = $client->post('UsersGroup', [GuzzleHttp\RequestOptions::JSON => $usersgroup_data]);
        if($response->getStatusCode() != 201){
          throw new RuntimeException(_txt('er.restdccprovisioner.usersgroup.create.failed') . ' (DccDocDbID = ' . $dccid . ')');
        } else {
          $this->CoProvisioningTarget->Co->CoPerson->HistoryRecord->record($coPersonId,
                                                                           null,
                                                                           null,
                                                                           // There should be a better way to get the actor but
                                                                           // at the moment there isn't
                                                                           CakeSession::read('Auth.User.co_person_id'),
                                                                           ActionEnum::ProvisionerAction,
                                                                           _txt('pl.restdccprovisioner.added', array($co_group_name)));
        } 
      }
    }

    // Iterate over the DocDB group members, removing any not in the COgroup
    foreach(array_keys($users_group) as $u){
      if(!array_key_exists($u, $co_users_in_group)){
        $response = $client->delete('UsersGroup/' . $users_group[$u]);
        if($response->getStatusCode() != 200){
          throw new RuntimeException(_txt('er.restdccprovisioner.usersgroup.delete.failed') . ' (UsersGroupID = ' . $users_group[$u] . ')');
        } else {
          $this->CoProvisioningTarget->Co->CoPerson->HistoryRecord->record($coPersonId,
                                                                           null,
                                                                           null,
                                                                           // There should be a better way to get the actor but
                                                                           // at the moment there isn't
                                                                           CakeSession::read('Auth.User.co_person_id'),
                                                                           ActionEnum::ProvisionerAction,
                                                                           _txt('pl.restdccprovisioner.removed', array($co_group_name)));
        }
      }
    }

    return true;
  }
  
  /**
   * Synchronize DCC access controlls for a CO Person.
   *
   * @since  COmanage Registry v3.2.3
   * @param  String  $restdcc_url Base URL of the DCC Server
   * @param  String  $client_id OAuth2 Client ID
   * @param  String  $client_id OAuth2 Client Secret
   * @param  String  $callback_url OAuth2 Callback URL
   * @param  String  $refresh_token DCC OAuth2 refresh token
   * @param  Array Provisioning data, populated with ['CoPerson'] or ['CoGroup']
   * @return Boolean true if person is successfully synced
   * @throws Exception
   */
  
  protected function syncGroupsForCoPerson($client, $security_group, $provisioningData, $activatePerson) {

    $coPersonId = $provisioningData['CoPerson']['id'];

    $dccid = null;
    foreach($provisioningData['Identifier'] as $i) {
      if($i['type'] == 'DccDocDbID') {
        $dccid = $i['identifier'];
        break;
      }
    }
    if(!$dccid){
      // avoid a race condition during id provisioning
      return true;
    }

    foreach($provisioningData['Identifier'] as $i) {
      if($i['type'] == 'np3mid') {
        $cosid = $i['identifier'];
        break;
      }
    }

    $given  = $provisioningData['PrimaryName']['given'];
    $middle = $provisioningData['PrimaryName']['middle'];
    $family = $provisioningData['PrimaryName']['family'];

    foreach($provisioningData['EmailAddress'] as $i) {
      if($i['type'] == 'official') {
        $email = $i['mail'];
        break;
      }
    }

    foreach($provisioningData['CoOrgIdentityLink'] as $i){
      if(!$i['deleted']) {
        foreach($i['OrgIdentity']['Identifier'] as $j){
          if($j['type'] == 'eppn'){
            $eppn = $j['identifier'];
          }
        }
      }
    }

    $co_person_org = htmlentities($provisioningData['CoPersonRole'][0]['o']);
    $response = $client->get('Institution?LongName=' . $co_person_org);
    if($response->getStatusCode() != 200 ) {
      throw new RuntimeException(_txt('er.restdccprovisioner.institution.notfound'));
    }
    $row = json_decode($response->getBody()->getContents(), true);
    $institution_id = $row[0]['InstitutionID'];

    $parts = explode( '@', $email );
    $abbr = $parts[0];

    $full_name = implode(' ', array_filter(array($given, $middle, $family)));
    $mi = '';
    if(!empty($middle)){
      $middle_parts = preg_split("/\s+/", $middle);
      foreach($middle_parts as $m){ 
        $mi .= $m[0];
      }
    }

    $author_data = array(
      'AuthorID' => $dccid,
      'FirstName' => substr($given, 0, 100),
      'MiddleInitials' => substr($mi, 0, 16),
      'LastName' => substr($family, 0, 100),
      'InstitutionID' => $institution_id,
      'Active' => $activatePerson,
      'AuthorAbbr' => substr($abbr, 0, 10),
      'FullAuthorName' => substr($full_name, 0, 256)
    );

    $remoteuser_data = array(
      'RemoteUserID' => $dccid,
      'RemoteUserName' => substr($eppn, 0, 255),
      'EmailUserID' => $dccid,
      'EmailAddress' => substr($email, 0, 255)
    );

    $emailuser_data = array(
      'EmailUserID' => $dccid,
      'Username' =>substr($cosid,0, 255),
      'Password' => '',
      'Name' => substr($full_name, 0, 255),
      'EmailAddress' => substr($email, 0, 255),
      'PreferHTML' => 0,
      'CanSign' => 0,
      'Verified' => 1,
      'AuthorID' => $dccid,
      'EmployeeNumber' => $dccid
    );

    $response = $client->get('Author/' . $dccid);
    $code = $response->getStatusCode();

    if ( $code == 200 ) {
      // Update existing user
      $response = $client->put('Author/' . $dccid, [GuzzleHttp\RequestOptions::JSON => $author_data]);
      if($response->getStatusCode() != 200) {
        throw new RuntimeException(_txt('er.restdccprovisioner.author.update.failed') . ' (DccDocDbID = ' . $dccid . ') ' . $full_name);
      }

      $response = $client->put('EmailUser/' . $dccid, [GuzzleHttp\RequestOptions::JSON => $emailuser_data]);
      if($response->getStatusCode() != 200) {
        throw new RuntimeException(_txt('er.restdccprovisioner.emailuser.update.failed') . ' (DccDocDbID = ' . $dccid . ') ' . $full_name);
      }

      $response = $client->put('RemoteUser/' . $dccid, [GuzzleHttp\RequestOptions::JSON => $remoteuser_data]);
      if($response->getStatusCode() != 200) {
        throw new RuntimeException(_txt('er.restdccprovisioner.remoteuser.update.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
      }

    } elseif ( $code == 404 ) {
      // Create new user
      $response = $client->post('Author', [GuzzleHttp\RequestOptions::JSON => $author_data]);
      if($response->getStatusCode() != 201) {
        throw new RuntimeException(_txt('er.restdccprovisioner.author.create.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
      }

      $response = $client->post('EmailUser', [GuzzleHttp\RequestOptions::JSON => $emailuser_data]);
      if($response->getStatusCode() != 201) {
        throw new RuntimeException(_txt('er.restdccprovisioner.emailuser.create.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
      }

      $response = $client->post('RemoteUser', [GuzzleHttp\RequestOptions::JSON => $remoteuser_data]);
      if($response->getStatusCode() != 201) {
        throw new RuntimeException(_txt('er.restdccprovisioner.remoteuser.create.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
      }
    } else {
      // Something went wrong
      throw new RuntimeException(_txt('er.restdccprovisioner.author.query.failed') . '(DccDocDbID = ' . $dccid . ')' . $full_name );
    }

    // Make a hash table of the user's current DocDB groups
    $response = $client->get('UsersGroup?EmailUserID=' . $dccid);
    if($response->getStatusCode() != 200) {
      throw new RuntimeException(_txt('er.restdccprovisioner.usersgroup.query.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
    }
    $users_group = array();
    $users_group_data = json_decode($response->getBody()->getContents(), true);
    foreach($users_group_data as $s) {
      $users_group[ $s['GroupID'] ] = $s['UsersGroupID'];
    }

    // Make a hash table of the user's current COmanage groups
    $co_groups = array();
    $co_groups_rev = array();
    foreach($provisioningData['CoGroupMember'] as $i){
      $co_group_name = $i['CoGroup']['name'];
      if(array_key_exists($co_group_name, $security_group)){
        $co_groups_rev[$security_group[$co_group_name]] = $co_group_name;
        $co_groups[$co_group_name] = $security_group[$co_group_name];
      }
    }

    // Iterate through the DocDB groups deleting memberships that are not in COmanage
    foreach(array_keys($users_group) as $u){
      if(!array_key_exists($u, $co_groups_rev)){
        $response = $client->delete('UsersGroup/' . $users_group[$u]);
        if($response->getStatusCode() != 200){
          throw new RuntimeException(_txt('er.restdccprovisioner.usersgroup.delete.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
        } else {
          $this->CoProvisioningTarget->Co->CoPerson->HistoryRecord->record($coPersonId,
                                                                           null,
                                                                           null,
                                                                           // There should be a better way to get the actor but
                                                                           // at the moment there isn't
                                                                           CakeSession::read('Auth.User.co_person_id'),
                                                                           ActionEnum::ProvisionerAction,
                                                                           _txt('pl.restdccprovisioner.removed', array($u)));
        } 
      }
    }

    // Iterate through the comanage groups adding to DocDB
    foreach(array_keys($co_groups) as $g){
      if(!array_key_exists($co_groups[$g], $users_group)){
        $usersgroup_data = array(
          'EmailUserID' => $dccid,
          'GroupID' => $co_groups[$g]
        );
        $response = $client->post('UsersGroup', [GuzzleHttp\RequestOptions::JSON => $usersgroup_data]);
        if($response->getStatusCode() != 201){
          throw new RuntimeException(_txt('er.restdccprovisioner.usersgroup.create.failed') . ' (DccDocDbID = ' . $dccid . ')' . $full_name);
        } else {
          // Success !
          $this->CoProvisioningTarget->Co->CoPerson->HistoryRecord->record($coPersonId,
                                                                           null,
                                                                           null,
                                                                           // There should be a better way to get the actor but
                                                                           // at the moment there isn't
                                                                           CakeSession::read('Auth.User.co_person_id'),
                                                                           ActionEnum::ProvisionerAction,
                                                                           _txt('pl.restdccprovisioner.added', array($g)));
        }
      }
    }

    return true;
  }

}
